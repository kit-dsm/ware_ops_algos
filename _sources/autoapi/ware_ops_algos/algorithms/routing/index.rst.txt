ware_ops_algos.algorithms.routing
=================================

.. py:module:: ware_ops_algos.algorithms.routing


Submodules
----------

.. toctree::
   :maxdepth: 1

   /autoapi/ware_ops_algos/algorithms/routing/routing/index
   /autoapi/ware_ops_algos/algorithms/routing/routing_and_batching/index


Attributes
----------

.. autoapisummary::

   ware_ops_algos.algorithms.routing.equivalence_classes
   ware_ops_algos.algorithms.routing.cross_aisle_mapping
   ware_ops_algos.algorithms.routing.table_I
   ware_ops_algos.algorithms.routing.table_II
   ware_ops_algos.algorithms.routing.aisle_mapping


Classes
-------

.. autoapisummary::

   ware_ops_algos.algorithms.routing.Algorithm
   ware_ops_algos.algorithms.routing.RoutingSolution
   ware_ops_algos.algorithms.routing.Route
   ware_ops_algos.algorithms.routing.PickPosition
   ware_ops_algos.algorithms.routing.RouteNode
   ware_ops_algos.algorithms.routing.NodeType
   ware_ops_algos.algorithms.routing.Resource
   ware_ops_algos.algorithms.routing.OrderPosition
   ware_ops_algos.algorithms.routing.Article
   ware_ops_algos.algorithms.routing.Routing
   ware_ops_algos.algorithms.routing.HeuristicRouting
   ware_ops_algos.algorithms.routing.SShapeRouting
   ware_ops_algos.algorithms.routing.ReturnRouting
   ware_ops_algos.algorithms.routing.MidpointRouting
   ware_ops_algos.algorithms.routing.LargestGapRouting
   ware_ops_algos.algorithms.routing.NearestNeighbourhoodRouting
   ware_ops_algos.algorithms.routing.PickListRouting
   ware_ops_algos.algorithms.routing.ExactRouting
   ware_ops_algos.algorithms.routing.ExactTSPRouting
   ware_ops_algos.algorithms.routing.ExactTSPRoutingDistance
   ware_ops_algos.algorithms.routing.ExactTSPRoutingDistanceWithWeightPrecedence
   ware_ops_algos.algorithms.routing.ExactTSPRoutingTime
   ware_ops_algos.algorithms.routing.ExactTSPRoutingMaxCompletionTime
   ware_ops_algos.algorithms.routing.RatliffRosenthalRouting


Package Contents
----------------

.. py:class:: Algorithm(seed: Optional[int] = None)

   Bases: :py:obj:`abc.ABC`, :py:obj:`Generic`\ [\ :py:obj:`I`\ , :py:obj:`O`\ ]


   Abstract base class for all algorithms (routing, batching, etc.).
   Handles timing, algo naming, and ensures consistent result metadata.


   .. py:attribute:: algo_name
      :type:  str
      :value: 'Algorithm'



   .. py:attribute:: logger


   .. py:method:: solve(input_data: I) -> O


.. py:class:: RoutingSolution

   Bases: :py:obj:`AlgorithmSolution`


   .. py:attribute:: route
      :type:  Optional[Route]
      :value: None



.. py:class:: Route

   .. py:attribute:: route
      :type:  list[tuple[int, int]] | None
      :value: None



   .. py:attribute:: item_sequence
      :type:  list[tuple[int, int]] | None
      :value: None



   .. py:attribute:: distance
      :type:  float
      :value: 0.0



   .. py:attribute:: pick_list
      :type:  Optional[PickList]
      :value: None



   .. py:attribute:: annotated_route
      :type:  Optional[list[RouteNode]]
      :value: None



.. py:class:: PickPosition

   .. py:attribute:: order_number
      :type:  int


   .. py:attribute:: article_id
      :type:  int


   .. py:attribute:: amount
      :type:  int


   .. py:attribute:: pick_node
      :type:  tuple[int, int]


   .. py:attribute:: in_store
      :type:  int


   .. py:attribute:: article_name
      :type:  Optional[str]
      :value: None



   .. py:attribute:: picked
      :type:  Optional[bool]
      :value: None



.. py:class:: RouteNode

   Bases: :py:obj:`NamedTuple`


   .. py:attribute:: position
      :type:  tuple[int, int]


   .. py:attribute:: node_type
      :type:  NodeType


.. py:class:: NodeType(*args, **kwds)

   Bases: :py:obj:`enum.Enum`


   Create a collection of name/value pairs.

   Example enumeration:

   >>> class Color(Enum):
   ...     RED = 1
   ...     BLUE = 2
   ...     GREEN = 3

   Access them by:

   - attribute access:

     >>> Color.RED
     <Color.RED: 1>

   - value lookup:

     >>> Color(1)
     <Color.RED: 1>

   - name lookup:

     >>> Color['RED']
     <Color.RED: 1>

   Enumerations can be iterated over, and know how many members they have:

   >>> len(Color)
   3

   >>> list(Color)
   [<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]

   Methods can be added to enumerations, and members can have their own
   attributes -- see the documentation for details.


   .. py:attribute:: PICK


   .. py:attribute:: ROUTE


.. py:class:: Resource

   .. py:attribute:: id
      :type:  int


   .. py:attribute:: capacity
      :type:  Optional[int]
      :value: None



   .. py:attribute:: speed
      :type:  Optional[float]
      :value: None



   .. py:attribute:: time_per_pick
      :type:  Optional[float]
      :value: None



   .. py:attribute:: pick_cart
      :type:  Optional[PickCart]
      :value: None



   .. py:attribute:: tpe
      :type:  ResourceType


   .. py:attribute:: occupied
      :type:  Optional[bool]
      :value: None



   .. py:attribute:: current_location
      :type:  Optional[tuple[float, float]]
      :value: None



.. py:class:: OrderPosition

   .. py:attribute:: order_number
      :type:  int


   .. py:attribute:: article_id
      :type:  int


   .. py:attribute:: amount
      :type:  int


   .. py:attribute:: article_name
      :type:  Optional[str]
      :value: None



   .. py:method:: from_dict(order_number: int, data: dict) -> OrderPosition
      :staticmethod:



.. py:class:: Article

   .. py:attribute:: article_id
      :type:  int


   .. py:attribute:: article_name
      :type:  Optional[str]
      :value: None



   .. py:attribute:: weight
      :type:  Optional[float]
      :value: None



   .. py:attribute:: volume
      :type:  Optional[float]
      :value: None



   .. py:method:: to_dict() -> dict[str, Any]


.. py:data:: equivalence_classes
   :value: [('U', 'U', '1C'), ('E', '0', '1C'), ('0', 'E', '1C'), ('E', 'E', '1C'), ('E', 'E', '2C'), ('0',...


.. py:data:: cross_aisle_mapping

.. py:data:: table_I

.. py:data:: table_II

.. py:data:: aisle_mapping

.. py:class:: Routing(start_node: tuple[int, int], end_node: tuple[int, int], closest_node_to_start: tuple[int, int], min_aisle_position: int, max_aisle_position: int, distance_matrix: pandas.DataFrame, predecessor_matrix: numpy.array, picker: list[ware_ops_algos.domain_models.Resource], gen_tour: bool = False, gen_item_sequence: bool = False, node_list: list[tuple[float, float]] = None, node_to_idx: dict = None, idx_to_node: dict = None, **kwargs)

   Bases: :py:obj:`ware_ops_algos.algorithms.algorithm.Algorithm`\ [\ :py:obj:`list`\ [\ :py:obj:`ware_ops_algos.algorithms.algorithm.PickPosition`\ ]\ :py:obj:`| list`\ [\ :py:obj:`ware_ops_algos.domain_models.OrderPosition`\ ]\ , :py:obj:`ware_ops_algos.algorithms.algorithm.RoutingSolution`\ ], :py:obj:`abc.ABC`


   Abstract base class for all algorithms (routing, batching, etc.).
   Handles timing, algo naming, and ensures consistent result metadata.


   .. py:attribute:: start_node


   .. py:attribute:: end_node


   .. py:attribute:: closest_node_to_start


   .. py:attribute:: min_aisle_position


   .. py:attribute:: max_aisle_position


   .. py:attribute:: pick_list
      :type:  Optional[list[ware_ops_algos.algorithms.algorithm.PickPosition]]
      :value: None



   .. py:attribute:: distance_matrix


   .. py:attribute:: predecessor_matrix


   .. py:attribute:: node_list
      :type:  list[tuple[float, float]]
      :value: None



   .. py:attribute:: node_to_idx
      :value: None



   .. py:attribute:: idx_to_node
      :value: None



   .. py:attribute:: gen_item_sequence
      :value: False



   .. py:attribute:: gen_tour
      :value: False



   .. py:attribute:: item_sequence
      :value: []



   .. py:attribute:: route
      :value: []



   .. py:attribute:: annotated_route
      :type:  list[ware_ops_algos.algorithms.algorithm.RouteNode]
      :value: []



   .. py:attribute:: distance
      :value: 0



   .. py:attribute:: current_order
      :type:  Optional[list[ware_ops_algos.algorithms.algorithm.PickPosition]]
      :value: None



   .. py:attribute:: picker


   .. py:attribute:: execution_time
      :value: None



   .. py:method:: reset_parameters()


.. py:class:: HeuristicRouting(start_node: tuple[int, int], end_node: tuple[int, int], closest_node_to_start: tuple[int, int], min_aisle_position: int, max_aisle_position: int, distance_matrix, predecessor_matrix, picker, fixed_depot=True, **kwargs)

   Bases: :py:obj:`Routing`, :py:obj:`abc.ABC`


   Base class for heuristic routing algorithms.


   .. py:attribute:: fixed_depot
      :value: True



.. py:class:: SShapeRouting(start_node: tuple[int, int], end_node: tuple[int, int], closest_node_to_start: tuple[int, int], min_aisle_position: int, max_aisle_position: int, distance_matrix, predecessor_matrix, picker, fixed_depot=True, **kwargs)

   Bases: :py:obj:`HeuristicRouting`


   Implements S-shape routing.


   .. py:attribute:: algo_name
      :value: 'SShapeRouting'



.. py:class:: ReturnRouting(start_node: tuple[int, int], end_node: tuple[int, int], closest_node_to_start: tuple[int, int], min_aisle_position: int, max_aisle_position: int, distance_matrix, predecessor_matrix, picker, fixed_depot=True, **kwargs)

   Bases: :py:obj:`HeuristicRouting`


   Implements Return routing.


   .. py:attribute:: algo_name
      :value: 'ReturnRouting'



.. py:class:: MidpointRouting(start_node: tuple[int, int], end_node: tuple[int, int], closest_node_to_start: tuple[int, int], min_aisle_position: int, max_aisle_position: int, distance_matrix, predecessor_matrix, picker, fixed_depot=True, **kwargs)

   Bases: :py:obj:`HeuristicRouting`


   Implements Midpoint routing.


   .. py:attribute:: algo_name
      :value: 'MidpointRouting'



   .. py:method:: split_orders_by_pickzone(resolved_positions, mid_point: int) -> tuple[list[ware_ops_algos.algorithms.algorithm.PickPosition], list[ware_ops_algos.algorithms.algorithm.PickPosition]]
      :staticmethod:



.. py:class:: LargestGapRouting(start_node: tuple[int, int], end_node: tuple[int, int], closest_node_to_start: tuple[int, int], min_aisle_position: int, max_aisle_position: int, distance_matrix, predecessor_matrix, picker, fixed_depot=True, **kwargs)

   Bases: :py:obj:`HeuristicRouting`


   Implements Largest Gap Routing for order picking in a warehouse.


   .. py:attribute:: algo_name
      :value: 'LargestGapRouting'



.. py:class:: NearestNeighbourhoodRouting(start_node: tuple[int, int], end_node: tuple[int, int], closest_node_to_start: tuple[int, int], min_aisle_position: int, max_aisle_position: int, distance_matrix, predecessor_matrix, picker, fixed_depot=True, **kwargs)

   Bases: :py:obj:`HeuristicRouting`


   A class to perform nearest neighbourhood routing for order picking in a warehouse using Dijkstra's algorithm.


   .. py:attribute:: algo_name
      :value: 'NearestNeighbourhoodRouting'



.. py:class:: PickListRouting(start_node: tuple[int, int], end_node: tuple[int, int], closest_node_to_start: tuple[int, int], min_aisle_position: int, max_aisle_position: int, distance_matrix, predecessor_matrix, picker, **kwargs)

   Bases: :py:obj:`HeuristicRouting`


   Base class for heuristic routing algorithms.


   .. py:attribute:: algo_name
      :value: 'PickListRouting'



.. py:class:: ExactRouting(start_node: tuple[int, int], end_node: tuple[int, int], distance_matrix: pandas.DataFrame, predecessor_matrix: dict, picker: list[ware_ops_algos.domain_models.Resource], big_m, set_time_limit, **kwargs)

   Bases: :py:obj:`Routing`, :py:obj:`abc.ABC`


   Base class for exact routing algorithms.


   .. py:attribute:: big_m


   .. py:attribute:: time_limit


   .. py:attribute:: length
      :value: None



   .. py:attribute:: pick_nodes
      :value: None



   .. py:attribute:: mdl
      :value: None



   .. py:attribute:: amount_at_pick_nodes
      :value: None



.. py:class:: ExactTSPRouting(start_node: tuple[int, int], end_node: tuple[int, int], distance_matrix: pandas.DataFrame, predecessor_matrix: dict, picker: list[ware_ops_algos.domain_models.Resource], big_m, set_time_limit, **kwargs)

   Bases: :py:obj:`ExactRouting`


   Implements the exact routing algorithm for the Traveling Salesman Problem (TSP).


   .. py:attribute:: T
      :value: None



   .. py:attribute:: C_max
      :value: None



   .. py:attribute:: x
      :value: None



   .. py:attribute:: x_start
      :value: None



   .. py:attribute:: x_end
      :value: None



   .. py:method:: construct_route_and_item_sequence()

      Generates the route for the exact routing algorithm from solution variables.



.. py:class:: ExactTSPRoutingDistance(start_node: tuple[int, int], end_node: tuple[int, int], distance_matrix: pandas.DataFrame, predecessor_matrix: numpy.array, picker: list[ware_ops_algos.domain_models.Resource], gen_tour, gen_item_sequence, big_m=1000, set_time_limit=300, **kwargs)

   Bases: :py:obj:`ExactTSPRouting`


   Implements the exact routing algorithm for the Traveling Salesman Problem (TSP) using distance as the objective.


   .. py:attribute:: algo_name
      :value: 'ExactTSPRoutingDistance'



.. py:class:: ExactTSPRoutingDistanceWithWeightPrecedence(start_node: tuple[int, int], end_node: tuple[int, int], distance_matrix: pandas.DataFrame, predecessor_matrix: numpy.array, picker: list[ware_ops_algos.domain_models.Resource], gen_tour, gen_item_sequence, articles: list[ware_ops_algos.domain_models.Article], big_m=1000, set_time_limit=300, **kwargs)

   Bases: :py:obj:`ExactTSPRouting`


   Implements the exact routing algorithm for TSP with weight-based precedence constraints.
   Heavy items must be picked before lighter items.


   .. py:attribute:: algo_name
      :value: 'ExactTSPRoutingDistanceWithWeightPrecedence'



   .. py:attribute:: articles


   .. py:attribute:: weights
      :value: []



.. py:class:: ExactTSPRoutingTime(start_node: tuple[int, int], end_node: tuple[int, int], distance_matrix: pandas.DataFrame, predecessor_matrix: dict, picker: list[ware_ops_algos.domain_models.Resource], gen_tour, gen_item_sequence, big_m, set_time_limit, **kwargs)

   Bases: :py:obj:`ExactTSPRouting`


   Implements the exact routing algorithm for the Traveling Salesman Problem (TSP) using time as the objective.


   .. py:attribute:: algo_name
      :value: 'ExactTSPRouting'



   .. py:attribute:: travel_time_matrix


.. py:class:: ExactTSPRoutingMaxCompletionTime(batched_list, distance_matrix, tour_matrix, picker, big_m, objective, **kwargs)

   Bases: :py:obj:`ExactTSPRouting`


   Implements the exact routing algorithm for the Traveling Salesman Problem (TSP) using maximum completion time as the objective.


   .. py:attribute:: algo_name
      :value: 'ExactTSPRoutingMaxCompletionTime'



.. py:class:: RatliffRosenthalRouting(start_node: tuple[int, int], end_node: tuple[int, int], closest_node_to_start: tuple[int, int], min_aisle_position: int, max_aisle_position: int, distance_matrix: pandas.DataFrame, predecessor_matrix: numpy.array, picker: list[ware_ops_algos.domain_models.Resource], n_aisles: int, n_pick_locations: int, dist_aisle: float, dist_pick_locations: float, dist_aisle_location: float, dist_start: float, dist_end: float, gen_tour: bool = False, gen_item_sequence: bool = False, **kwargs)

   Bases: :py:obj:`Routing`


   Abstract base class for all algorithms (routing, batching, etc.).
   Handles timing, algo naming, and ensures consistent result metadata.


   .. py:attribute:: algo_name
      :value: 'RatliffRosenthalRouting'



   .. py:attribute:: state_graph


   .. py:attribute:: n_aisles


   .. py:attribute:: n_pick_locations


   .. py:attribute:: dist_aisle


   .. py:attribute:: dist_pick_locations


   .. py:attribute:: dist_aisle_location


   .. py:attribute:: dist_start


   .. py:attribute:: dist_end


   .. py:attribute:: depot


   .. py:method:: build_state_space()


   .. py:method:: largest_gap(order_list: list[ware_ops_algos.algorithms.algorithm.PickPosition])
      :staticmethod:



   .. py:method:: one_pass()


   .. py:method:: two_pass()


   .. py:method:: top(pick_node_y: int)


   .. py:method:: bottom(pick_node_y: int)


   .. py:method:: gap(gap_size: int)


   .. py:method:: void()


   .. py:method:: cross_aisle_cost(cross_aisle_action: tuple[int, int])


   .. py:method:: cost_fn_wrapper(order_subset: list[ware_ops_algos.algorithms.algorithm.PickPosition], transition: str, node=None)


   .. py:method:: get_item_sequence_from_path() -> list[ware_ops_algos.algorithms.algorithm.PickPosition]

      Extracts the ordered pick sequence from the dynamic programming path (self.path).
      :returns: ordered item sequence along the optimal tour.
      :rtype: list[PickPosition]



   .. py:method:: plot_picker_tour(T: networkx.MultiGraph)

      Visualizes the picker tour graph T as a 2D warehouse layout.
      Nodes are (aisle, pick_y) positions.



